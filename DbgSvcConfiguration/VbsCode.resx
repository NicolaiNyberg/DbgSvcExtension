<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PerExeTemplate" xml:space="preserve">
    <value>Const ACTIONS_NEED_CLR_EXCEPTION_TYPES = False
Const ACTIONS_NEED_CLR_EXCEPTION_MSGS = False
Const MAX_NATIVE_EXCEPTION_STACKS_PER_SECOND = 30
Const MAX_NATIVE_EXCEPTION_STACKS_PER_EXCEPTION_TYPE = 100
Const MAX_VARIANTS_PER_EXCEPTION_TYPE = 20
Const MAX_CLR_EXCEPTION_DETAILS_PER_SECOND = 30
Const MAX_CLR_EXCEPTION_STACKS_PER_SECOND = 20
Const MAX_CLR_EXCEPTION_STACKS_PER_EXCEPTION_TYPE = 10
Const MAX_CLR_EXCEPTION_STACKS_TOTAL = 100
Const CRASH_RULE_LOGGING_ENABLED = True
Const INCLUDE_EXCEPTION_SUMMARY = True
Const PREVENT_SOS = True
Debugger.DumpPath = "C:\Program Files\DebugDiag\Logs\Crash rule for all instances of {0}"
RuleKey = "Crash-TT-1-TNAME-{1}"
' BEGIN STATIC CODE

Dim ServiceController
Dim ServiceState
Dim g_DeferredManagedBreakpointExpressions
Dim g_CLRObjectOffSets, g_ManagedDumpMTCache, g_SizeOfULongPtr, g_DumpStackObjects, g_ClrInited
Dim g_exceptions, g_exceptionDetails, g_clrExceptionCountsPerExceptionType, g_natvieExceptionCountsPerExceptionType, g_TotalClrExceptionStacksCollected
Dim g_ExceptionInfoDuringPreviousWindow
Dim g_ExceptionInfoDuringThisWindow
Dim g_CurrentExceptionWindow
Dim g_limitedExceptionDetails 
Dim g_ManagedIp2mdCache
Dim g_IgnoreNextAV
Dim g_msvbvm60Start, g_msvbvm60End
Dim g_LikelyClrExceptionKbArg
Dim g_lastPrintedTime
Dim g_registerPrefix, g_pointerLabel
Dim g_OmissionMessages
Dim g_exceptionVariantsByType

Const NOT_FOUND = "NOT_FOUND"
Const EXCEPTION_WINDOW_SIZE = 10

SetBitness()

Set g_CLRObjectOffSets = CreateObject("Scripting.Dictionary")    	
Set g_ManagedDumpMTCache = CreateObject("Scripting.Dictionary")
Set g_exceptions = CreateObject("Scripting.Dictionary")
Set g_exceptionDetails = CreateObject("Scripting.Dictionary")
Set g_ExceptionInfoDuringThisWindow = CreateObject("Scripting.Dictionary")
Set g_ManagedIp2mdCache = CreateObject("Scripting.Dictionary")
Set g_clrExceptionCountsPerExceptionType = CreateObject("Scripting.Dictionary")
Set g_NativeExceptionCountsPerExceptionType = CreateObject("Scripting.Dictionary")
Set g_OmissionMessages = CreateObject("Scripting.Dictionary")
Set g_exceptionVariantsByType = CreateObject("Scripting.Dictionary")

Set DbgState = Debugger.State
g_CurrentExceptionWindow  = -1
Debugger.SourceInfoEnabled = True

If CRASH_RULE_LOGGING_ENABLED = False Then 
    Debugger.Write "Crash rule logging is disabled." &amp; vblf
    Debugger.Write "To modify this option, go to the 'Crash Rule Preferences' tab of the 'Tools | Options And Settings ...' dialog in DebugDiag.Collection.exe"
End If

On Error Resume Next
    Set ServiceController = CreateObject("DbgSVC.Controller")
    If Err.number &lt;&gt; 0 Then
        WriteToLog "An error occurred while creating the ServiceController: " &amp; Err.number &amp; " : " &amp; Err.Description
    Else
        Set ServiceState = ServiceController.ServiceState        
        If Err.number &lt;&gt; 0 Then
            WriteToLog "An error occurred while retrieving the ServiceState: " &amp; Err.number &amp; " : " &amp; Err.Description
            Err.Clear
        End If

        Dim Processes
        Set Processes = ServiceController.Processes
        If Err.number &lt;&gt; 0 Then
            WriteToLog "An error occurred while retrieving the Processes: " &amp; Err.number &amp; " : " &amp; Err.Description
            Err.Clear
        Else

            Dim Process, pid
            pid = Debugger.ProcessID
            Set Process = Processes.GetProcessByProcessID(pid)
            If Err.number &lt;&gt; 0 Then
                WriteToLog "An error occurred while retrieving the Process for PID " &amp; pid &amp; ": " &amp; Err.number &amp; " : " &amp; Err.Description
                Err.Clear
            Else
                Process.RuleKey = RuleKey
            End If
        End If
    End If
On Error Goto 0

RecreateDeferredManagedBreakpointExpressionsCollectionIfNecessary

Sub WriteToLog(ByVal Output)	
	WriteToLogNoLF Output &amp; vblf
End Sub

Sub WriteToLogNoLF(ByVal Output)
	DebuggerWrite CurrentTime_Small
    DebuggerWrite Output
End Sub

Sub DebuggerWrite(ByVal Output)
    If CRASH_RULE_LOGGING_ENABLED = False Then Exit Sub
    Debugger.Write Output
End Sub

Function CurrentTime_Small
    Dim currentTime
    currentTime = Now

    If DateDiff("s", g_lastPrintedTime, currentTime) &lt; 1 Then
        CurrentTime_Small = "  "
    Else
        g_lastPrintedTime = currentTime
        CurrentTime_Small = "[" &amp; g_lastPrintedTime &amp; "]" &amp; vbLf &amp; "  "
    End If
End Function

Sub CreateDump(ByVal DumpReason, ByVal bMiniDump)
	Dim DumpLimitVarName
	Dim DumpCountVarName
	Dim DumpLimit
	Dim DumpCount
	
	If IsEmptyOrNothing(ServiceState) Then
		DumpName = Debugger.CreateDump(DumpReason, bMiniDump)
		WriteToLog "Created dump file " &amp; DumpName
		WriteLogFooter
	Else
		DumpLimitVarName = RuleKey &amp; "_DUMP_LIMIT"
		DumpCountVarName = RuleKey &amp; "_DUMP_COUNT"
		
		DumpLimit = CInt(ServiceState(DumpLimitVarName))
		DumpCount = CInt(ServiceState(DumpCountVarName))
		If DumpCount &lt; DumpLimit Then
			DumpName = Debugger.CreateDump(DumpReason, bMiniDump)
			WriteToLog "Created dump file " &amp; DumpName
			
			DumpCount = DumpCount + 1
			ServiceState(DumpCountVarName) = DumpCount
			If DumpCount = DumpLimit Then
				WriteToLog "Crash rule dump limit of " &amp; DumpLimit &amp; " reached. No more dump files will be created"
			End If
			WriteLogFooter
		End If
	End If
	
End Sub

Sub AdjustDumpCountOnUnhandledException()
	Dim DumpCountVarName
	Dim DumpCount
	
	If Not IsEmptyOrNothing(ServiceState) Then
		DumpCountVarName = RuleKey &amp; "_DUMP_COUNT"
		DumpCount = CInt(ServiceState(DumpCountVarName))
		DumpCount = DumpCount + 1
		ServiceState(DumpCountVarName) = DumpCount
	End If
End Sub

Function AddBreakpoint(BreakpointExpression, IsManaged)
    Dim LogString
    Dim bpID  

    LogString = "Attempting to set "
    If Not IsManaged Then LogString = LogString &amp; "un"
    LogString = LogString &amp; "managed breakpoint at " &amp; BreakpointExpression                 
    WriteToLog LogString           
    
	bpID = Debugger.AddCodeBreakpoint(BreakpointExpression, IsManaged)	

    If IsManaged Then
        If bpID &lt; -1 Then
            RecreateDeferredManagedBreakpointExpressionsCollectionIfNecessary
            If IsEmptyOrNothing(g_DeferredManagedBreakpointExpressions) Then Exit Function

            If g_DeferredManagedBreakpointExpressions.Exists(BreakpointExpression) Then
                g_DeferredManagedBreakpointExpressions(BreakpointExpression) = bpID
            Else
                g_DeferredManagedBreakpointExpressions.Add BreakpointExpression, bpID
            End If
        End If     
    End If
    	
	DbgState("BP_" &amp; BreakpointExpression &amp; "_ID") = bpID
	                
    WriteToLog "bpID = " &amp; bpID
    	
	AddBreakpoint = bpID
End Function

Sub LogStack
    DebuggerWrite Debugger.Execute("kb 1000")
    If Not Debugger.IsClrExtensionMissing Then
        DebuggerWrite Debugger.Execute("!clrstack")
    End If
End Sub

Sub UpdateDeferredManagedBreakpoints()        
    Dim i
    Dim bpID
    Dim BreakpointExpression

    RecreateDeferredManagedBreakpointExpressionsCollectionIfNecessary
    If IsEmptyOrNothing(g_DeferredManagedBreakpointExpressions) Then Exit Sub
    If g_DeferredManagedBreakpointExpressions.Count = 0 Then Exit Sub
    
    WriteToLog "UpdateDeferredManagedBreakpoints - Current Breakpoint List(BL)"
    DebuggerWrite Debugger.Execute("bl")
    
    For i = g_DeferredManagedBreakpointExpressions.Count - 1 to 0 Step -1
        bpID = g_DeferredManagedBreakpointExpressions.Items()(i)
        BreakpointExpression = g_DeferredManagedBreakpointExpressions.Keys()(i)
        
        If bpID = -3 Then
            ' This managed breakpoint hasn't been added yet (CLR may not have been loaded the last time we tried)
            bpID = AddBreakpoint(BreakpointExpression, True)
        Else
            ' A deferred managed breakpoint was previously added before the module was loade or before the method was JITed
            ' See if the module has been loaded and/or the method has been JITted since then
            bpID = FindDeferredManagedBreakpoint(BreakpointExpression)
        End If                
        
        If bpID &gt; -1 Then
            ' This breakpoint has been successfully added.  Remove this entry from the deferred list.
            g_DeferredManagedBreakpointExpressions.Remove BreakpointExpression
        End If        
    Next
End Sub

Function Name2IP(ByVal Name)
    Dim Output, SearchText, pos, pos2, start
    
    Output = Debugger.Execute("!name2ee " &amp; Name)
    SearchText = "JITTED Code Address:"
    
    pos = InStr(Output, SearchText)
    If pos &gt; 0 Then
        pos2 = Instr(pos, Output , vblf)
        If pos2 &gt; pos Then
            start = pos + Len(SearchText) + 1
            Name2IP = Mid(Output, start, pos2 - start)
        End If
    End If
End Function

Function TrimLeadingZeros(str)
    Dim length, i
    
    length = Len(str)
    For i = 1 To length
        If Mid(str, i, 1) &lt;&gt; "0" Then
            TrimLeadingZeros = Mid(str, i)
            Exit Function
        End If
    Next    
End Function

Function FindDeferredManagedBreakpoint(ByVal BreakpointExpression)
    Dim bpID, IP, Output, Lines, Line, Tokens, retry
    
    FindDeferredManagedBreakpoint = -2
    
    IP = TrimLeadingZeros(Name2IP(BreakpointExpression))
    If IP = "" Then Exit Function    

    For retry = 1 To 2
        Output = Debugger.Execute("bl")
        Output = Replace(Output, "`", "")
        
        If InStr(Output, IP) &gt; 0 Then
            Lines = Split(Output, vblf)
            For i = 0 To UBound(Lines)		
                Line = Lines(i)
                If InStr(Line, IP) &gt; 0 Then
                    Tokens = SplitNoEmpty(Line, " ", 3)
                    If Ubound(Tokens) = 2 Then
                        If IP = TrimLeadingZeros(Tokens(2)) Then
                            bpID = CInt(Tokens(0))                            
                            FindDeferredManagedBreakpoint = bpID
                            DbgState("BP_" &amp; BreakpointExpression &amp; "_ID") = bpID           
                            WriteToLog "Deferred managed breakpoint found for " &amp; BreakpointExpression &amp; vblf &amp; "bpID = " &amp; bpID
                            Exit Function
                        End If
                    End If
                End If
            Next
        End If
        
        ' For some reason !bpmd didn't work.
        ' The method has been jitted after calling !bpmd, but there is no matching breakpoint set.
        ' Try adding it again now.
        WriteToLog "Deferred managed breakpoint expected but not found for " &amp; BreakpointExpression
        AddBreakpoint BreakpointExpression, True
    Next
End Function

Function SplitNoEmpty(ByVal str, ByVal delim, ByVal limit)
    Dim ar, lb, ub, i, NonEmptyHits
    
    ar = Split(str, delim)
    lb = LBound(ar)
    ub = UBound(ar)
    If ub &gt; limit Then ub = limit
    
    For i = lb To ub
        If ar(i) &lt;&gt; "" Then            
            ar(NonEmptyHits) = ar(i)
            NonEmptyHits = NonEmptyHits + 1
            
            If NonEmptyHits = limit Then Exit For
        End If
    Next
    
    Redim Preserve ar(NonEmptyHits - 1)
    SplitNoEmpty = ar
End Function

Function GetThreadID(ByVal Thread)
    Dim ID
    
    On Error Resume Next
    ID = "System ID: " &amp; Thread.SystemID
    On Error Goto 0
    If Err.Number &lt;&gt; 0 Then
        ID = "Logical ID: " &amp; Thread.ThreadID
    End If
    
    GetThreadID = ID 
End Function

Function GetThreadID_Short(ByVal Thread)
    On Error Resume Next
    GetThreadID_Short = Thread.SystemID
    If Err.Number &lt;&gt; 0 Then
        GetThreadID_Short = "w/ Logical ID "
        GetThreadID_Short = GetThreadID_Short &amp; Thread.ThreadID
    End If
    On Error Goto 0
End Function

Function IsEmptyOrNothing(ByVal obj)
    If Not IsEmpty(obj) Then
        If IsObject(obj) Then
            If Not obj Is Nothing Then
                IsEmptyOrNothing = False
                Exit Function
            End If
        End If
    End If
    
    IsEmptyOrNothing = True
End Function

Sub RecreateDeferredManagedBreakpointExpressionsCollectionIfNecessary
    If IsEmptyOrNothing(g_DeferredManagedBreakpointExpressions) Then Set g_DeferredManagedBreakpointExpressions = CreateObject("Scripting.Dictionary")
End Sub

Function GetCleanNativeStack(exceptionRate, exceptionCode)
    If Not INCLUDE_EXCEPTION_SUMMARY Then Exit Function

    If exceptionRate &gt; MAX_NATIVE_EXCEPTION_STACKS_PER_SECOND Then 
        GetCleanNativeStack = vbtab &amp; vbtab &amp; "(omitted)"
        AddOmissionMsg "Native exception rate is more than MAX_NATIVE_EXCEPTION_STACKS_PER_SECOND (" &amp; MAX_NATIVE_EXCEPTION_STACKS_PER_SECOND &amp; " exceptions / sec)"
        Exit Function
    End If

    Dim exceptionCountPerExceptionCode
    exceptionCountPerExceptionCode = GetNativeExceptionCount(exceptionCode)
    If exceptionCountPerExceptionCode &gt; MAX_NATIVE_EXCEPTION_STACKS_PER_EXCEPTION_TYPE Then
        GetCleanNativeStack = vbtab &amp; vbtab &amp; "(omitted)"
        AddOmissionMsg "The maximum number of stacks (MAX_NATIVE_EXCEPTION_STACKS_PER_EXCEPTION_TYPE = " &amp; MAX_NATIVE_EXCEPTION_STACKS_PER_EXCEPTION_TYPE &amp; ") for this native exception type have been collected: '" &amp; exceptionCode &amp; "'"
        Exit Function
    End If

    Dim output, lines, line, stackStarted
    output = Debugger.Execute("k")

    Lines = Split(Output, vblf)
    If UBound(Lines) &lt; 0 Then Exit Function

    If g_SizeOfULongPtr = 4 Then
        trimLen = 18 'X86
    Else
        trimLen = 36 'X64
    End If
       
    For i = 0 To UBound(Lines)
        line = Lines(i)
        If Left(line, 3) &lt;&gt; "***" Then 
            If stackStarted Then
                lineLen = Len(line)
                If lineLen &gt; trimLen Then
                    GetCleanNativeStack = GetCleanNativeStack &amp; vbtab &amp; vbtab &amp; Right(line, lineLen - trimLen) &amp; vblf
                End If
            Else
                If UCASE(Left(line, 8)) = "CHILD-SP" Then
                    stackStarted = True
                End If
            End If
        End If
    Next
End Function

Function GetClrExceptionVariantCount(ByVal clrExceptionType, ByVal clrExceptionMsg)
    Dim variants, key
        
    If g_exceptionVariantsByType.Exists(clrExceptionType) Then
        Set variants = g_exceptionVariantsByType.Item(clrExceptionType)
    Else
        set variants = CreateObject("Scripting.Dictionary")
        g_exceptionVariantsByType.Add clrExceptionType, variants
    End If
    
    If variants.Count &lt; MAX_VARIANTS_PER_EXCEPTION_TYPE Then
        key = clrExceptionMsg ' &amp; "|" &amp; address
        If Not variants.Exists(key) Then 
            variants.Add key, key
        End If
    End If

    GetClrExceptionVariantCount = variants.Count
End Function

Function GetClrExceptionCountPerExceptionType(ByVal clrExceptionType, ByVal clrExceptionMsg)
    Dim key, count
    key = clrExceptionType &amp; "|" &amp; clrExceptionMsg '&amp; "|" &amp; address

    If g_clrExceptionCountsPerExceptionType.Exists(key) Then
        count = g_clrExceptionCountsPerExceptionType.Item(key) + 1
        g_clrExceptionCountsPerExceptionType(key) = count
    Else
        count = 1
        g_clrExceptionCountsPerExceptionType.Add key, count
    End If

    GetClrExceptionCountPerExceptionType = count
End Function

Function GetNativeExceptionCount(ByVal exceptionCode)
    Dim key, count
    key = exceptionCode '&amp; "|" &amp; address

    If g_nativeExceptionCountsPerExceptionType.Exists(key) Then
        count = g_nativeExceptionCountsPerExceptionType.Item(key) + 1
        g_nativeExceptionCountsPerExceptionType(key) = count
    Else
        count = 1
        g_nativeExceptionCountsPerExceptionType.Add key, count
    End If

    GetNativeExceptionCount = count
End Function

Sub AddOmissionMsg(msg)
    If Not g_OmissionMessages.Exists(msg) Then g_OmissionMessages.Add msg, vbEmpty
End Sub

Sub DisplayOmissionMessages
    Dim msg
    If g_OmissionMessages.Count &gt; 0 Then
        DebuggerWrite vbLf &amp; vbLf &amp; "**** Some exception details were omitted due to the following reasons" &amp; vbLf
        For Each msg in g_OmissionMessages.Keys
            DebuggerWrite vbTab &amp; msg &amp; vbLf
        Next
    End If
End Sub

Sub DisplayDebuggingCost
    Dim totalTicks, totalDbgHostTicks, totalScriptTicks
    Debugger.GetDebuggerTicks totalTicks, totalDbgHostTicks, totalScriptTicks
    Debugger.Write vbLf &amp; "Debugging Overhead Cost:" &amp; vbLf &amp; _
        vbTab &amp; "Total Elapsed Ticks = " &amp; totalTicks &amp; " (100%)" &amp; vbLf &amp; _
        vbTab &amp; "Total Ticks Spent in Debugger Engine = " &amp; totalDbgHostTicks &amp; " (" &amp; 100 * Round(totalDbgHostTicks/totalTicks, 2) &amp; "%)" &amp; vbLf &amp; _
        vbTab &amp; "Total Ticks Spent in Crash Rule Script = " &amp; totalScriptTicks &amp; " (" &amp; 100 * Round(totalScriptTicks/totalTicks, 2) &amp; "%)" &amp; vbLf
End Sub

Function GetCleanClrStack(ByVal clrExceptionRate, ByVal clrExceptionType, ByVal clrExceptionMsg)
    If Not INCLUDE_EXCEPTION_SUMMARY Then Exit Function

    Dim exceptionCountPerExceptionType

    If clrExceptionRate &gt; MAX_CLR_EXCEPTION_STACKS_PER_SECOND Then 
        GetCleanClrStack = vbtab &amp; vbtab &amp; "(omitted)"
        AddOmissionMsg "CLR exception rate is more than MAX_CLR_EXCEPTION_STACKS_PER_SECOND (" &amp; MAX_CLR_EXCEPTION_STACKS_PER_SECOND &amp; " exceptions / sec)"
        Exit Function
    End If

    exceptionCountPerExceptionType = GetClrExceptionCountPerExceptionType(clrExceptionType, clrExceptionMsg)
    If exceptionCountPerExceptionType &gt; MAX_CLR_EXCEPTION_STACKS_PER_EXCEPTION_TYPE Then
        GetCleanClrStack = vbtab &amp; vbtab &amp; "(omitted)"
        AddOmissionMsg "The maximum number of stacks (MAX_CLR_EXCEPTION_STACKS_PER_EXCEPTION_TYPE = " &amp; MAX_CLR_EXCEPTION_STACKS_PER_EXCEPTION_TYPE &amp; ") for this CLR exception type have been collected: '" &amp; clrExceptionType &amp; "'"
        Exit Function
    End If

    If g_TotalClrExceptionStacksCollected &gt;= MAX_CLR_EXCEPTION_STACKS_TOTAL Then
        GetCleanClrStack = vbtab &amp; vbtab &amp; "(omitted)"
        AddOmissionMsg "The maximum number of total stacks (MAX_CLR_EXCEPTION_STACKS_TOTAL = " &amp; MAX_CLR_EXCEPTION_STACKS_TOTAL &amp; ") for all CLR exception types have been collected)"
        Exit Function
    End If
    g_TotalClrExceptionStacksCollected = g_TotalClrExceptionStacksCollected + 1


    Dim output, lines, line, stackStart, lineCount

    output = Debugger.Execute("!clrstack")
    Lines = Split(Output, vblf)
    lineCount = UBound(Lines) + 1
    For i = 0 To lineCount - 1
        Line = Lines(i)

        If stackStart = 0 Then	
            If Left(Line, 9) = "OS Thread" Then
                stackStart = i + 2                
            End If
        ElseIf i &gt;= stackStart Then
            Dim space
            space = Instr(line, " ")
            If space &gt; 0 Then
                space = Instr(space + 1, line, " ")
                If space &gt; 0 Then
                    line = Mid(line, space + 1)
                    If (Left(line, 1)) = "[" Then
                        Dim colon
                        colon = Instr(line, ":")
                        If colon &gt; 0 Then
                            line = Left(line, colon - 1) &amp; "]"
                        End If
                    End If
                    While Left(Line, 3) = "***" And i &lt; lineCount
                        i = i + 1
                        Line = Lines(i)
                    WEnd
                    
                    GetCleanClrStack = GetCleanClrStack &amp; vbtab &amp; vbtab &amp; line &amp; vblf
                End If
            End If
        End If
    Next
End Function

Function GetExceptionDetailsID(details)
    If Not INCLUDE_EXCEPTION_SUMMARY Then Exit Function

    Dim idCountArray
    ' g_exceptionDetails is a collection where:
    '    - the 'key' is the full details of the exception (clr type, vb6 error #, message text, call stack, inner exception info)
    '    - the 'value' is the idCountArray for that exception
    ' idCountArray is a 2-element array where element (0) is the ID for the exception type and element (1) is the # of times this exception has occurred.
    ' The ID of the exception type is the 1-based position in the g_exceptionDetails collection for the exception type

    If g_exceptionDetails.Exists(details) Then
        idCountArray = g_exceptionDetails.Item(details)
        GetExceptionDetailsID = idCountArray(0)
        idCountArray(1) = idCountArray(1) + 1
        g_exceptionDetails.Item(details) = idCountArray
    Else
        idCountArray = Array(g_exceptionDetails.Count + 1, 1)
        g_exceptionDetails.Add details, idCountArray
        GetExceptionDetailsID = idCountArray(0)
    End If
End Function

' This performs better than using the Thread.StackFrames.Args(), since collecting the entire stack is expensive and we just want the args off the first few frames
Function GetStackArgs(threadID, numFrames)
    Dim output
    output = Debugger.Execute("~" &amp; threadID &amp; "kb" &amp; numFrames)

    GetStackArgs = GetStackArgsFromKbOutput(output, numFrames)
End Function

Function GetStackArgsFromKbOutput(output, numFrames)
    Dim line, lines, lineNum, lastLineNum, frameNum, lineLen, lastLineItemNum, badLine, argsPerFrame, numArgsFound
    frameNum = 0
    numArgsFound = 0

    If g_SizeOfULongPtr = 4 Then
        expectedLen = 8 'X86
        argsPerFrame = 3
    Else
        expectedLen = 17 'X64
        argsPerFrame = 4
    End If

    ReDim kbArgsArray(numFrames - 1, argsPerFrame - 1)

    lines = Split(output, vbLf)
    lastLineNum = UBound(lines)

    For lineNum = 0 To lastLineNum
        line = lines(lineNum)
        lineLen = Len(line)
        badLine = False

        lineItems = Split(line, " ")
        lastLineItemNum = UBound(lineItems)
        If lastLineItemNum &gt;= 5 Then
            ' Validate the line format
            For lineItemNum = 0 To 4
                If g_SizeOfULongPtr = 4 Or lineItemNum &lt;&gt; 1 Then ' skip the 2nd line item on X64  (it's " : ")
                    lineItem = lineItems(lineItemNum)
                    If Len(lineItem) &lt;&gt; expectedLen Then
                        badLine = True
                        Exit For
                    End If
                End If
            Next

            ' Extract the arguments
            If Not badLine Then
                For lineItemNum = 2 To argsPerFrame + 1
                    kbArgsArray(frameNum, lineItemNum - 2) = lineItems(lineItemNum)
                    numArgsFound = numArgsFound + 1
                Next
                frameNum = frameNum + 1
            End If
        End If

        If frameNum = numFrames Then Exit For
    Next

    GetStackArgsFromKbOutput = kbArgsArray
End Function

Sub ClrInit()
    If g_ClrInited Then Exit Sub
    g_ClrInited = True

    Dim clrModule, isClrV4OrHigher
    Set clrModule = Debugger.GetModuleByModuleName("clr")
    If Not clrModule Is Nothing Then
        Dim major, minor, build, revision
        clrModule.GetFileVersion major, minor, build, revision

        If major &gt;= 4 Then
            isClrV4OrHigher = True
        Else
            isClrV4OrHigher = False
        End If
    End If

    If isClrV4OrHigher Then
        If g_SizeOfULongPtr = 8 Then
            g_LikelyClrExceptionKbArg = Array(0, 2) 'X64 V4+
        Else
            g_LikelyClrExceptionKbArg = Array(2, 1) 'X86 V4+
        End If
    Else
        g_LikelyClrExceptionKbArg = Array(2, 0) 'X86 and X64 v2
    End If
End Sub

Function GetManagedExceptionPtr_WithExts(ByVal ExceptionThread, ByRef clrExceptionType)
    Dim exceptionObject

    ' First try !pe
    exceptionObject = FindObjectFromPE(ExceptionThread.ThreadID)
    clrExceptionType = GetManagedExceptionType(exceptionObject)

    If clrExceptionType = NOT_FOUND Then
        ' Then try !dso
        RePopulateDSOCacheForThread(ExceptionThread.ThreadID)

        exceptionObject = FindObjectFromDSO("Exception", ExceptionThread.ThreadID, True)
        clrExceptionType = GetManagedExceptionType(exceptionObject)
    End If

    GetManagedExceptionPtr_WithExts = exceptionObject
End Function

Function GetManagedExceptionPtr_WithoutExts(ByVal ExceptionThread, ByRef clrExceptionType)
    Dim kbArgsArray, exceptionObject, frameNum, argNum

    ' try kb args
    kbArgsArray = GetStackArgs(ExceptionThread.ThreadID, 3)

    ' first, try the most likely kb arg...
    exceptionObject = GetManagedExceptionPtrFromKbArgsArray(kbArgsArray, g_LikelyClrExceptionKbArg(0), g_LikelyClrExceptionKbArg(1), clrExceptionType)

    ' Then try all of the kb args
    Dim bFound
    bFound = False
    If clrExceptionType &lt;&gt; NOT_FOUND Then bFound = True

    If Not bFound Then
        For frameNum = 0 To UBound(kbArgsArray, 1)
            For argNum = 0 To UBound(kbArgsArray, 2)
                exceptionObject = GetManagedExceptionPtrFromKbArgsArray(kbArgsArray, frameNum, argNum, clrExceptionType)
                If clrExceptionType &lt;&gt; NOT_FOUND Then 
                    bFound = True
                    Exit For
                End If
            Next
            If bFound Then Exit For
        Next
    End If

    ' Then try raw stack pointers (simulate !dso)
    If Not bFound Then
        Dim sp
        sp = ExceptionThread.Register(g_registerPrefix &amp; "sp")

        For i = 1 To 200
            If g_SizeOfULongPtr = 8 Then
                clrExceptionType = GetManagedExceptionType(Debugger.GetAs64BitHexString(sp + i * g_SizeOfULongPtr))
            Else
                clrExceptionType = GetManagedExceptionType(Debugger.GetAs32BitHexString(sp + i * g_SizeOfULongPtr))
            End If
            If clrExceptionType &lt;&gt; NOT_FOUND Then
                bFound = True
                Exit For
            End If
        Next
    End If

    If bFound Then 
        GetManagedExceptionPtr_WithoutExts = exceptionObject
    Else
        GetManagedExceptionPtr_WithoutExts = NOT_FOUND
    End If
End Function


Function GetManagedExceptionPtrFromKbArgsArray(kbArgsArray, frameNum, argNum, ByRef clrExceptionType)
    Dim exceptionObject
    exceptionObject = kbArgsArray(frameNum, argNum)
    clrExceptionType = GetManagedExceptionType(exceptionObject)
    GetManagedExceptionPtrFromKbArgsArray = exceptionObject
End Function

Function GetManagedExceptionPtr(ByVal ExceptionThread, ByRef clrExceptionType, clrExceptionRate)
    Dim exceptionObject

    If (INCLUDE_EXCEPTION_SUMMARY = False) And (ACTIONS_NEED_CLR_EXCEPTION_TYPES = False) And (ACTIONS_NEED_CLR_EXCEPTION_MSGS = False) Then
          Exit Function
    End If

    If (clrExceptionRate &gt; MAX_CLR_EXCEPTION_DETAILS_PER_SECOND) And (ACTIONS_NEED_CLR_EXCEPTION_TYPES = False) And (ACTIONS_NEED_CLR_EXCEPTION_MSGS = False) Then
        GetManagedExceptionPtr = NOT_FOUND
        clrExceptionType = "CLR Exception (details omitted - see below)"
        AddOmissionMsg "CLR exception rate is more than MAX_CLR_EXCEPTION_DETAILS_PER_SECOND (" &amp; MAX_CLR_EXCEPTION_DETAILS_PER_SECOND &amp; " exceptions / sec)"
        Exit Function
    End If

    exceptionObject = GetManagedExceptionPtr_WithoutExts(ExceptionThread, clrExceptionType)
    If clrExceptionType = NOT_FOUND Then
        If Not PREVENT_SOS Then
            exceptionObject = GetManagedExceptionPtr_WithExts(ExceptionThread, clrExceptionType)
        End If
    End If

    GetManagedExceptionPtr = exceptionObject
End Function

Function FindObjectFromPE(threadID)
    Dim Output, Lines, i
    
    Output = Debugger.Execute("!pe")
    Lines = Split(Output, Chr(10))
    For i = 0 To UBound(Lines)
	    If Left(Lines(i), 18) = "Exception object: " Then
		    FindObjectFromPE = Trim(Mid(Lines(i), 19))
		    Exit For
	    End If
    Next
End Function

    Function GetManagedExceptionType(ByVal ExceptionObjHexAddr)
        GetManagedExceptionType = NOT_FOUND

        If DumpObjectInternal(ExceptionObjHexAddr, "_stackTraceString", "LONG") &lt;&gt; NOT_FOUND Then
            GetManagedExceptionType = DumpString(ExceptionObjHexAddr, "_className")

            If GetManagedExceptionType = NOT_FOUND Then
                GetManagedExceptionType = getManagedObjectType(ExceptionObjHexAddr)
            End If
        End If
    End Function

Function GetManagedExceptionMsg(ByVal ExceptionObjHexAddr)
    If (INCLUDE_EXCEPTION_SUMMARY = False) And (ACTIONS_NEED_CLR_EXCEPTION_MSGS = False) Then Exit Function
	GetManagedExceptionMsg = DumpString(ExceptionObjHexAddr, "_message")
End Function


Function getManagedObjectType(objHexAddr)   
    Dim methodTable
    methodTable = DumpObject(objHexAddr, "")

    If methodTable &lt;&gt; NOT_FOUND then
        getManagedObjectType = GetManagedTypeFromMT(methodTable)
    else
        getManagedObjectType = NOT_FOUND
    End If
End Function 'getManagedObjectType
    
Function GetManagedTypeFromMT(methodTable)
    Dim TypeName
    Dim Output, Lines, i
    
    If Not g_ManagedDumpMTCache.Exists(methodTable) Then    
        Output = Debugger.Execute("!dumpmt " &amp; methodTable)
        Lines = Split(Output, Chr(10))
        For i = 0 To UBound(Lines)		
            If Len(Lines(i)) &gt;= 7 Then
	            If InStr(Lines(i), "Name: ") = 1 Then
		            TypeName = Trim(Mid(Lines(i), 7))
		            Exit For
	            End If
            End If
        Next
    
        g_ManagedDumpMTCache.Add methodTable, TypeName
    End If
    
    GetManagedTypeFromMT = g_ManagedDumpMTCache.Item(methodTable)
End Function 'GetManagedTypeFromMT

Function DumpString(objectAddress, fieldName)
	Dim stringAddress
	stringAddress = DumpObjectInternal(objectAddress, fieldName, "OBJECT")	
	DumpString = DumpStringVal(stringAddress)
End Function

Function DumpStringVal(stringAddress)
	if stringAddress = NOT_FOUND Then
        DumpStringVal = NOT_FOUND
    else
        DumpStringVal = DumpObjectInternal(stringAddress,"m_firstChar", "STRING")
    End If
End Function

Function DumpObject(objectAddress, fieldName)
	DumpObject = DumpObjectInternal(objectAddress, fieldName, "OBJECT")	
End Function

Function DumpObjectInternal(objectAddress, fieldName, TypeToDump)
	Dim methodTable, objectOffSetsDictionary, tempObjectOffSetDict, actualOffSet
    
    If objectAddress = NOT_FOUND or objectAddress ="" or IsEmpty(objectAddress) or IsNull(objectAddress) then
        DumpObjectInternal = NOT_FOUND
        exit function
    end if 

    
	If g_SizeOfULongPtr = 8 then
	    methodTable = Debugger.ReadQWord(FromHex(objectAddress))	
	else
	    methodTable = Debugger.ReadDWord(FromHex(objectAddress))	
	End If
	
	If g_CLRObjectOffSets.Exists(methodTable) then
		Set objectOffSetsDictionary = g_CLRObjectOffSets.Item(methodTable)
	else
		Set objectOffSetsDictionary = CreateManagedFieldsOffsetsDictionary(methodTable)		        
		g_CLRObjectOffSets.Add methodTable,objectOffSetsDictionary
	end if

    If objectOffSetsDictionary is Nothing then
        DumpObjectInternal = NOT_FOUND
        exit function
    End If
    	
	'This is the dictionary object to use objectOffSetsDictionary
	
    If objectOffSetsDictionary.Exists (fieldName) or fieldName = "" then

        if fieldName = "" then
            actualOffSet = 0
        else
            actualOffSet = objectOffSetsDictionary.Item(fieldName)
        end if
        
        Dim stringAddress, isQuad, actualString
        stringAddress = NOT_FOUND	
        'check for x64
        isQuad = (g_SizeOfULongPtr = 8)
    
        If TypeToDump = "SHORT" then
		    stringAddress = Cstr(Debugger.ReadWord(FromHex(objectAddress) + FromHex(actualOffSet)))
		
		ElseIf TypeToDump = "BYTE" then
		    stringAddress = Cstr(Debugger.ReadByte(FromHex(objectAddress) + FromHex(actualOffSet)))
		
	    ElseIf TypeToDump = "STRING" then
		        'In this case we are just dumping a raw string
		    stringAddress  = FromHex(objectAddress) +  FromHex(actualOffSet)
		    stringAddress  = Debugger.ReadUnicodeString(stringAddress)
		    	
	    ElseIf TypeToDump ="LONG" then 
		    stringAddress = Cstr(Debugger.ReadDWord(FromHex(objectAddress) + FromHex(actualOffSet)))
		   

        ElseIf TypeToDump ="QUAD" then 
		    stringAddress = Debugger.GetAs64BitHexString(Debugger.ReadQWord(FromHex(objectAddress) + FromHex(actualOffSet))) 
            stringAddress = Replace(stringAddress, "`", "" )
            stringAddress = Replace(stringAddress, "0x", "" )
		    
	    ElseIf TypeToDump ="GUID" then    
	        stringAddress = GetGUIDString(FromHex(objectAddress) + FromHex(actualOffSet))
				
	    ElseIf TypeToDump ="OBJECT" then 
		    if isQuad = false then
			    stringAddress = Debugger.GetAs32BitHexString(Debugger.ReadDWord(FromHex(objectAddress) + FromHex(actualOffSet)))
			    stringAddress = Replace(stringAddress, "0x", "" )
		    else 
			    stringAddress = Debugger.GetAs64BitHexString(Debugger.ReadQWord(FromHex(objectAddress) + FromHex(actualOffSet)))
			    stringAddress = Replace(stringAddress, "`", "" )
			    stringAddress = Replace(stringAddress, "0x", "" )
		    end if
		    
	    End If
	    
        If stringAddress = "00000000" or stringAddress = "0000000000000000"  then
            stringAddress = NOT_FOUND
        End If
    End If
	
    DumpObjectInternal = stringAddress
End Function 'DumpObjectInternal

Sub SetBitness()
    If InStr(Debugger.execute(".effmach"), "64") &gt; 0 Then 
        g_SizeOfULongPtr = 8
        g_registerPrefix = "r"
        g_pointerLabel = "q"
    Else
        g_SizeOfULongPtr = 4
        g_registerPrefix = "e"
        g_pointerLabel = "d"
    End If
End Sub

Function FromHex(byval theHexStr)    
    on error resume next
    if lcase(left(theHexStr, 2)) = "0x" then
        theHexStr = mid(theHexStr, 3)
    end if
    
    'Replace the /n characther as that messes the HexToDec Function
    theHexStr = Replace(theHexStr,vblf,"")
    'Just replace the ` charachter  if this is passed
    theHexStr = Replace(theHexStr,"`","")
    dim tmpValue

    If g_SizeOfULongPtr = 8 then
        FromHex = HexToDec(theHexStr)
    else
        tmpValue = CLng("&amp;h" &amp; theHexStr) 
        FromHex = tmpValue
        
        'This code added for 32-bit dumps taken on x64
        If tmpValue &lt; 0 then
            FromHex =  HexToDec(theHexStr)
        End If
        
    end if

    on error goto 0
End Function

Function HexToDec(strHex)    
    Dim i    
    Dim size    
    Dim ret    
    size = Len(strHex)
    
    If size &lt; 8 Then 
        HexToDec = CLng("&amp;h" &amp; StrHex)
        Exit Function
    ElseIf size = 8 Then
        If CInt("&amp;H" &amp; Left(strHex, 1) ) &lt;= 7 Then  ' Avoid values such as 0xFFFFFFFF
            HexToDec = CLng("&amp;h" &amp; StrHex)
            Exit Function
        End If
    ElseIf size = 16 Then
        If Left(strHex, 8) = "00000000" Then   ' Avoid values such as 0x00000000`FFFFFFFF        
            If CInt("&amp;H" &amp; Mid(strHex, 9, 1) ) &lt;= 7 Then
                HexToDec = CLng("&amp;h" &amp; Mid(StrHex, 9))
                Exit Function
            End If
        End If
    End If

    ' Don't optimize for values such as 0x00`FFFFFFFF        

    ret = CDbl(0)    
    For i = 0 To size - 1 
        ret = ret + CDbl("&amp;H" &amp; Mid(strHex, size - i, 1)) * (CDbl(16) ^ CDbl(i))    
    Next    
    HexToDec = ret
End Function

Function CreateManagedFieldsOffsetsDictionary(methodTable)
	Dim eeClass, dumpClassOutput, tempObjectOffSetDict, arrayFieldNames
	eeClass = GetEEClassFromMethodTable(methodTable)
	
	if eeClass &lt;&gt; "" then
		dumpClassOutput = Debugger.Execute("!DumpClass " + eeClass)
		Set tempObjectOffSetDict = CreateObject("Scripting.Dictionary")
		
		PopulateDictionaryObjectWithFieldsAndOffSet tempObjectOffSetDict, dumpClassOutput
		
		'By now the Dictionary is populated so lets return it
		
		Set CreateManagedFieldsOffsetsDictionary = tempObjectOffSetDict
	else
		Set CreateManagedFieldsOffsetsDictionary = Nothing
	
	end if
End Function

Function GetEEClassFromMethodTable(methodTable)
	dim eeClassString, eeClassStringArray, eeClassLineEntry, eeClassLineEntryArray, i
	
	eeClassString = Debugger.Execute("!dumpmt 0n" &amp; methodTable)
	eeClassStringArray = Split(eeClassString,vbLf)

    'Introducing the for loop as at times we may get this output
    '"WARNING: Teb 48 pointer is NULL - defaulting to 7ffd4000
    'WARNING: 7ffd4000 does not appear to be the right TEB
    'WARNING: Teb 48 pointer is NULL - defaulting to 7ffd4000
    'WARNING: 7ffd4000 does not appear to be the right TEB
    'EEClass: 0818af00
    
	for i = lbound(eeClassStringArray) to ubound (eeClassStringArray)
		eeClassLineEntry = eeClassStringArray(i)
		If Instr(eeClassLineEntry,"EEClass") &gt; 0 then
		    'below code changed a bit for 1.1 and 4.0
            eeClassLineEntry = Trim(eeClassLineEntry)
			eeClassLineEntryArray = Split(eeClassLineEntry,":")			

			If UBOUND(eeClassLineEntryArray) &gt; 0 then
				GetEEClassFromMethodTable = eeClassLineEntryArray(1)
                exit function			   		

			End If
        End If
    Next

	GetEEClassFromMethodTable = ""				
End Function

' utility Function removing extra whitespace and replacing it with a single space
' for example " some text here" will be converted to " some text here"
Function normalizeWhitespace(stringToTrim) 
	While Instr(stringToTrim, "       ")
	    stringToTrim = Replace(stringToTrim, "       ", " ")
	Wend
	
	While Instr(stringToTrim, "  ")
	    stringToTrim = Replace(stringToTrim, "  ", " ")
	Wend
	
	normalizeWhitespace = stringToTrim
End Function

Sub PopulateDictionaryObjectWithFieldsAndOffSet(ByRef tempObjectOffSetDict, dumpClassOutput)
	
	Dim dumpClassOutputArray, startIndex, i, oneLineInArrayOutPut
	Dim ArrayOfFieldsToReturn()
	dumpClassOutputArray  = Split(dumpClassOutput,vbLf)
        startIndex = vbEmpty

	for i = 0 to UBOUND(dumpClassOutputArray)
		oneLineInArrayOutPut = normalizeWhitespace(dumpClassOutputArray(i))
		if Instr(UCASE(oneLineInArrayOutPut),"MT FIELD") &gt; 0 then
			startIndex = i+1
			exit for			
		End If
	next
	
	Dim j, oneLineInOutput 	
	for i = startIndex to UBOUND(dumpClassOutputArray)
		oneLineInOutput = normalizeWhitespace(dumpClassOutputArray(i))
		
		if oneLineInOutput = "" or Instr(oneLineInOutput ,"&gt;&gt;") &gt; 0 or  Instr(oneLineInOutput ,"&lt;&lt;") &gt; 0 or Instr(oneLineInOutput ," static ") &gt; 0 then
			'ignore this one. This is a static entry
		else
			Dim oneLineInOutputArray
			oneLineInOutputArray = Split (oneLineInOutput, " ")

			if UBOUND(oneLineInOutputArray) &gt;= 6 then	
                If oneLineInOutputArray(6) = "instance" then
                    fieldName = oneLineInOutputArray(7)
                else
                    fieldName = oneLineInOutputArray(6)
                End If
                fieldValue = oneLineInOutputArray(2)

                if Not tempObjectOffSetDict.Exists(fieldName) then		
                    tempObjectOffSetDict.Add fieldName, fieldValue	
                end if
                
             elseif UBOUND(oneLineInOutputArray) = 5 then	' THIS IS ADDED FOR .NET 4.0 where SOS displays MT as 00000000 , in this case 4th column is empty and hence our parsing breaks. discovered first for _thread in httpcontext
                if Not tempObjectOffSetDict.Exists(oneLineInOutputArray(5)) then		
				    tempObjectOffSetDict.Add oneLineInOutputArray(5), fieldValue
                end if
			end if
		end if
	Next	
End Sub

Sub RePopulateDSOCacheForThread(intThreadId)
    Dim FindStackOutput
	FindStackOutput = Debugger.Execute("~" &amp; intThreadId &amp; "e!DumpStackObjects")    
    Set g_DumpStackObjects = CreateObject("Scripting.Dictionary")
    g_DumpStackObjects.Add intThreadId, FindStackOutput
End Sub


Function FindObjectFromDSO(objectType, intThreadId, stopOnFirstObject)
    Dim dsoArray, webRequestObjectLineInStack, dsoOutput, aFoundIdx, webRequestObjectLineInStackArr, objToReturn, i
    
	objToReturn = Null
	
    If g_DumpStackObjects.Count = 0 Then
        PopulateDSOCache
    End If

    If  g_DumpStackObjects.Exists(intThreadId) Then
        dsoOutput  = g_DumpStackObjects.Item(intThreadId)
        If InStr(dsoOutput,objectType) &gt; 0 then
            dsoArray = split(dsoOutput,vbLf)
	        webRequestObjectLineInStack = ""
	        for i = lbound(dsoArray)+2 to ubound(dsoArray) - 1
	            if Trim(dsoArray(i)) &lt;&gt; "" then
	                If Right(dsoArray(i), len(objectType)) = objectType then
	                    webRequestObjectLineInStack = dsoArray(i)
	                    webRequestObjectLineInStack = normalizewhitespace(webRequestObjectLineInStack)
			            webRequestObjectLineInStackArr = split(webRequestObjectLineInStack)
			            If UBOUND(webRequestObjectLineInStackArr) &gt; 1 then
			                If stopOnFirstObject = true then
    			                FindObjectFromDSO = webRequestObjectLineInStackArr(1)
    			                Exit Function
    			            Else
    			                If IsNull(objToReturn) Then
    			                    objToReturn = webRequestObjectLineInStackArr(1) 
    			                Else    			                    
    			                    If Not (Instr(UCASE(objToReturn), ucase(webRequestObjectLineInStackArr(1))) &gt; 0)  then
        			                    objToReturn = objToReturn &amp; "," &amp; webRequestObjectLineInStackArr(1)
                                    End If
    			                End If
    			                
			                End IF
			            End If
	                End if
                End If
	        next    
        Else
            objToReturn = Null
        End If
    
    End If
    
    FindObjectFromDSO = objToReturn
    
End Function

Function Tabs(count)
    Dim i
    for i = 1 to count
     Tabs = Tabs &amp; vbTab
    next
End Function

Sub Debugger_OnDebuggerDetach()
    WriteToLog "Debugger is detaching"
    WriteLogFooter
End Sub

Sub WriteLogFooter
    If INCLUDE_EXCEPTION_SUMMARY Then
        WriteClrExceptionDetails
        WriteExceptionSummary
    Else
        DebuggerWrite vbLf &amp; "Exception statistics are disabled in user preferences."  &amp; vblf
        DebuggerWrite "To modify this option, go to the 'Crash Rule Preferences' tab of the 'Tools | Options And Settings ...' dialog in DebugDiag.Collection.exe"  &amp; vblf
    End If
    
    DisplayOmissionMessages
    DisplayDebuggingCost
End Sub

Sub WriteClrExceptionDetails
    Dim detailID, idCountArray, count

    If g_exceptionDetails.Count = 0 Then Exit Sub
    DebuggerWrite vblf 
    DebuggerWrite "***********************" &amp; vblf
    DebuggerWrite "*  EXCEPTION DETAILS  *" &amp; vblf
    DebuggerWrite "***********************" &amp; vblf
    DebuggerWrite vblf 

    For Each detail In g_exceptionDetails.Keys
        detailID = detailID + 1
        DebuggerWrite "DetailID = " &amp; detailID &amp; vblf
        idCountArray = g_exceptionDetails.Item(detail)
        count = idCountArray(1)
        DebuggerWrite vbtab &amp; "Count:    " &amp; count &amp; vblf
        DebuggerWrite detail &amp; vblf
    Next
End Sub

Sub WriteExceptionSummary
    Dim exceptionCode, exceptionCount
    Dim maxExceptionCodeLen, maxExceptionCountLen
    Dim exceptionCodeLen, exceptionCountLen
    Dim exceptionCodePadding, exceptionCountPadding
    Dim temp

    If g_exceptions.Count = 0 Then Exit Sub

    Dim exceptions()
    ReDim exceptions(g_exceptions.Count - 1)

    exceptionCodeLen = 9 'len("Exception")
    exceptionCountLen = 5 'len("Count")
    maxExceptionCodeLen = exceptionCodeLen
    maxExceptionCountLen = exceptionCountLen

    ' populate
    For Each exceptionCode in g_exceptions.Keys
        exceptions(i) = Array(g_exceptions(exceptionCode), exceptionCode)
        i = i + 1

    Next

    ' sort
    For i = 0 to ubound(exceptions)
        For j = i + 1 to ubound(exceptions)
            If exceptions(i)(0) &lt; exceptions(j)(0) Then
                temp = exceptions(j)
                exceptions(j) = exceptions(i)
                exceptions(i) = temp
            End If
        Next

        exceptionCount = exceptions(i)(0)
        exceptionCountLen = Len(exceptionCount) 
        If exceptionCountLen &gt; maxExceptionCountLen Then 
            maxExceptionCountLen = exceptionCountLen
        End If

        exceptionCode = exceptions(i)(1)
        exceptionCodeLen = Len(exceptionCode) 
        If exceptionCodeLen &gt; maxExceptionCodeLen Then 
            maxExceptionCodeLen = exceptionCodeLen
        End If
    Next

    ' write

    DebuggerWrite vblf 
    DebuggerWrite vblf 
    DebuggerWrite vblf 
    DebuggerWrite "***********************" &amp; vblf
    DebuggerWrite "*  EXCEPTION SUMMARY  *" &amp; vblf
    DebuggerWrite "***********************" &amp; vblf  
    DebuggerWrite vblf 

    Dim horizLine
    horizLine = vbtab &amp; "|" &amp; MakeString("-", maxExceptionCodeLen + maxExceptionCountLen + 5) &amp; "|" &amp; vblf  
    DebuggerWrite horizLine

    exceptionCodeLen = 9 'len("Exception")
    exceptionCountLen = 5 'len("Count")
    exceptionCodePadding = GetPadding(exceptionCodeLen, maxExceptionCodeLen)
    exceptionCountPadding = GetPadding(exceptionCountLen, maxExceptionCountLen)


    DebuggerWrite vbtab &amp; "| Count" &amp; exceptionCountPadding &amp; " | Exception" &amp; exceptionCodePadding &amp; " |" &amp; vblf  
    DebuggerWrite horizLine


    For i = 0 to ubound(exceptions)
        exceptionCount = exceptions(i)(0)
        exceptionCountLen = len(exceptionCount)
        exceptionCountPadding = GetPadding(exceptionCountLen, maxExceptionCountLen)

        exceptionCode = exceptions(i)(1)
        exceptionCodeLen = len(exceptionCode)
        exceptionCodePadding = GetPadding(exceptionCodeLen, maxExceptionCodeLen)

        DebuggerWrite vbtab &amp; "| " &amp; exceptionCount &amp; exceptionCountPadding &amp; " | " &amp; exceptionCode &amp; exceptionCodePadding &amp; " |" &amp; vblf  
    Next

    DebuggerWrite horizLine

    If g_limitedExceptionDetails Then
        DebuggerWrite vblf &amp; vblf &amp; "To protect performance, not all exception details were recorded due to the high number of exceptions in the target process.  " &amp; vblf
        DebuggerWrite "To modify this option, go to the 'Crash Rule Preferences' tab of the 'Tools | Options And Settings ...' dialog in DebugDiag.Collection.exe"  &amp; vblf
    End If
End Sub

Function GetPadding(theLen, maxLen)
    If maxLen &gt; theLen Then
        GetPadding = Space(maxLen - theLen)
    Else
        GetPadding = ""
    End If
End Function

Function MakeString(str, count)
    Dim i
    For i = 1 to count
        MakeString = MakeString &amp; str
    Next
End Function

Function IsJITCode(ip, bLoadIfMissing)
    Dim Output, isJIT, ipHex

    'ipHex =  Hex(ip)
    If Not g_ManagedIp2mdCache.Exists(ip) Then
        If Not bLoadIfMissing Then 
            Exit Function
        End If

        Output = Debugger.Execute("!ip2md 0n" &amp; ip)
        If InStr(Output, "Method Name: ") &gt; 1 Then 
            isJIT = True
        Else
        End If
        g_ManagedIp2mdCache.Add ip, isJIT
    End If
    
    IsJITCode = g_ManagedIp2mdCache.Item(ip)
End Function 

Function IsIgnorableAV

    Dim output
    output = UCase(Debugger.Execute("kc2"))
    If InStr(output, "KERNELBASE!") = 0 Then
        If InStr(output, "KERNEL32!") = 0 Then
            Exit Function
        End If
    End If

    If InStr(output, "CLR!") = 0 Then
        If InStr(output, "MSCORWKS!") = 0 Then
            Exit Function
        End If
    End If

    IsIgnorableAV = True
End Function

Sub HandleException(ByVal Exception, ByVal ExceptionCode, ByVal CausingThread, ByVal FirstChance, ByRef ClrExceptionType, ByRef ClrExceptionMsg)
    Dim exceptionInfoIndex
    Dim thisExceptionWindow
    Dim exceptionCount, previousExceptionCount
    Dim exceptionRate
	Dim clrExceptionPtr
	Dim vbErrorNum, vbErrorDesc, vbErrorSrc
    Dim maxExceptionsPerSecond, isClrException

	If ExceptionCode = "0XE0434F4D" Then 
        isClrException = True
        ExceptionCode = "CLR Exception"
    ElseIf ExceptionCode = "0XE0434352" Then 
        isClrException = True
        ExceptionCode = "CLR Exception"
    ElseIf ExceptionCode = "0XC0000005" Then
        If g_IgnoreNextAV &gt; 0 Then            

            If IsIgnorableAV Then 
                g_IgnoreNextAV = g_IgnoreNextAV - 1
                Exit Sub
            End If
        End If

        If g_ExceptionInfoDuringThisWindow.Exists("clr") Then exceptionCount = g_ExceptionInfoDuringThisWindow.Item("clr")

        If IsJITCode(CausingThread.InstructionAddress, exceptionCount / EXCEPTION_WINDOW_SIZE &lt;= MAX_CLR_EXCEPTION_DETAILS_PER_SECOND) Then
            isClrException = True
            ExceptionCode = "System.NullReferenceException"
        End If
    End If

	If isClrException Then
        exceptionInfoIndex = 0
        maxExceptionsPerSecond = MAX_CLR_EXCEPTION_DETAILS_PER_SECOND
    Else
        exceptionInfoIndex = 1
        maxExceptionsPerSecond = MAX_NATIVE_EXCEPTION_STACKS_PER_SECOND
    End If

    thisExceptionWindow = Second(Now) \ EXCEPTION_WINDOW_SIZE
    If thisExceptionWindow &lt;&gt; g_CurrentExceptionWindow Then
        ' Time to advance to the next window
        g_CurrentExceptionWindow = thisExceptionWindow
        If Not IsEmpty(g_ExceptionInfoDuringPreviousWindow) Then
            g_ExceptionInfoDuringPreviousWindow.RemoveAll
            Set g_ExceptionInfoDuringPreviousWindow = Nothing
        End If
        Set g_ExceptionInfoDuringPreviousWindow = g_ExceptionInfoDuringThisWindow
        Set g_ExceptionInfoDuringThisWindow = CreateObject("Scripting.Dictionary")
    End If

    ' Increment the exception count and save it
    If g_ExceptionInfoDuringThisWindow.Exists(ExceptionCode) Then exceptionCount = g_ExceptionInfoDuringThisWindow.Item(ExceptionCode) 
    exceptionCount = exceptionCount + 1
    g_ExceptionInfoDuringThisWindow.Item(ExceptionCode) = exceptionCount

    ' Take the larger exception count from this window and previous window
    If g_ExceptionInfoDuringPreviousWindow.Exists(ExceptionCode) Then previousExceptionCount = g_ExceptionInfoDuringPreviousWindow.Item(ExceptionCode) 
    If previousExceptionCount &gt; exceptionCount Then exceptionCount = previousExceptionCount

    exceptionRate = exceptionCount / EXCEPTION_WINDOW_SIZE


	Select Case ExceptionCode
		Case "CLR Exception"
			clrExceptionPtr = GetManagedExceptionPtr(CausingThread, clrExceptionType, exceptionRate)
            If clrExceptionPtr &lt;&gt; NOT_FOUND Then
                If clrExceptionType &lt;&gt; NOT_FOUND Then
			        clrExceptionMsg = GetManagedExceptionMsg(clrExceptionPtr)
                End If
            End If
			If clrExceptionType &lt;&gt; NOT_FOUND Then ExceptionCode = clrExceptionType

			exceptionLine = GetClrExceptionDetails(clrExceptionPtr, clrExceptionType, clrExceptionMsg, exceptionRate)

        Case "System.NullReferenceException"
            g_IgnoreNextAV = g_IgnoreNextAV + 1
			exceptionLine = GetClrExceptionDetails(clrExceptionPtr, ExceptionCode, "", exceptionRate)

        Case "0XC000008F"
            GetVBErrorInfo Exception, CausingThread, vbErrorNum, vbErrorDesc, vbErrorSrc
            exceptionLine = GetVB6ExceptionDetails(vbErrorNum, vbErrorSrc, vbErrorDesc, exceptionRate)

        Case "0XC0000005"
            exceptionLine = GetNativeExceptionDetails(ExceptionCode, exceptionRate)

        Case Else
            exceptionLine = GetNativeExceptionDetails(ExceptionCode, exceptionRate)
	End Select

	If g_exceptions.Exists(ExceptionCode) Then 
		g_exceptions(ExceptionCode) = g_exceptions(ExceptionCode) + 1
	Else
		g_exceptions(ExceptionCode) = 1
	End If

	If FirstChance Then
        exceptionLine = ExceptionCode &amp; " on thread " &amp; GetThreadID_Short(CausingThread)  &amp; "." &amp; exceptionLine
        If Not isClrException Then exceptionLine = "Exception " &amp; exceptionLine
        If Len(exceptionLine) &lt; 37 Then
            exceptionLine = exceptionLine &amp; String(37 - Len(exceptionLine), " ")
        End If
		WriteToLogNoLF exceptionLine
	Else
		WriteToLogNoLF "Second chance exception - " &amp; ExceptionCode &amp; " caused by thread with " &amp; GetThreadID(CausingThread) &amp; exceptionLine
		AdjustDumpCountOnUnhandledException
	End If
End Sub

Sub GetVBErrorInfo(ByVal Exception, ByVal ExceptionThread, ByRef ErrorNum, ByRef ErrorDesc, ByRef ErrorSrc)
	dim ebx		
	dim pfnDeferredFillIn
	dim fnDeferredFillInStr	
	dim kbArgsArray
	dim kbOutput

    If INCLUDE_EXCEPTION_SUMMARY = False Then Exit Sub

    If g_msvbvm60Start = 0 Then
        Dim msvbvm60
        Set msvbvm60 = Debugger.GetModuleByModuleName("MSVBVM60")
        If msvbvm60 Is Nothing Then
            g_msvbvm60Start = -1
            g_msvbvm60End = -1 
        Else
            g_msvbvm60Start = msvbvm60.Base
            g_msvbvm60End = g_msvbvm60Start + msvbvm60.Size
        End If
    End If

    If g_msvbvm60Start &gt; 0 Then	 
	ebx = ExceptionThread.Register("ebx")
	pfnDeferredFillIn = Debugger.ReadDWord(ebx+&amp;H18)
        If pfnDeferredFillIn &gt; g_msvbvm60Start And pfnDeferredFillIn &lt; g_msvbvm60End Then	' (should be BasicExcepDeferredFillIn)
            ErrorNum = Debugger.GetAs32BitHexString(Debugger.ReadDWord(ebx+&amp;H1c))
            If Left(UCASE(ErrorNum), 6) = "0X800A" Then
                ErrorNum = CLng("&amp;H" &amp; Right(ErrorNum, 4))
                ErrorDesc = Debugger.ReadUnicodeString(Debugger.ReadDWord(ebx+&amp;H8))
                ErrorSrc = Debugger.ReadUnicodeString(Debugger.ReadDWord(ebx+&amp;H4))
            Else
                ErrorNum = Empty
            End If
        End If
    End If

    If IsEmpty(ErrorNum) Then
        kbOutput = UCase(Debugger.Execute("kb2"))
        kbArgsArray = GetStackArgsFromKbOutput(kbOutput, 2)
        If UBound(kbArgsArray) &lt; 1 Then Exit Sub
        ErrorNum = kbArgsArray(1, 1)
        If Left(UCASE(ErrorNum), 6) = "0X800A" Then
            ErrorNum = CLng("&amp;H" &amp; Right(ErrorNum, 4))
        End If
    End If
End Sub

Function GetClrExceptionDetails(ByVal clrExceptionPtr, ByVal clrExceptionType, ByVal clrExceptionMsg, ByVal exceptionRate)
    If Not CRASH_RULE_LOGGING_ENABLED Then Exit Function

    If Not INCLUDE_EXCEPTION_SUMMARY Then 
        GetClrExceptionDetails = GetClrExceptionDetails &amp; vbLf
        Exit Function
    End If

    Dim tabCount, clrStack
    Dim details
    Dim uniqueMessagesCount
    Dim colExceptionPtrs

    Set colExceptionPtrs = CreateObject("Scripting.Dictionary")
    clrStack = GetCleanClrStack(exceptionRate, clrExceptionType, clrExceptionMsg)
    tabCount = 1

    Do
        details = details &amp; Tabs(tabCount) &amp; "Type:     " &amp; clrExceptionType &amp; vblf
        details = details &amp; Tabs(tabCount) &amp; "Message:  "

        uniqueMessagesCount = GetClrExceptionVariantCount(clrExceptionType, clrExceptionMsg)
        If uniqueMessagesCount = MAX_VARIANTS_PER_EXCEPTION_TYPE Then
            details = details &amp; "(omitted)"
            AddOmissionMsg "The maximum number of unique messages (MAX_VARIANTS_PER_EXCEPTION_TYPE = " &amp; MAX_VARIANTS_PER_EXCEPTION_TYPE &amp; ") for this CLR exception type have been collected: '" &amp; clrExceptionType &amp; "'"
        Else
            details = details &amp; clrExceptionMsg &amp; vblf
        End If

        clrExceptionPtr = DumpObject(clrExceptionPtr, "_innerException")
        If clrExceptionPtr = NOT_FOUND Then Exit Do
        If colExceptionPtrs.Exists(clrExceptionPtr) Then
            details = details &amp; "**EXITING INFINITELY RECURSIVE EXCEPTION HIERARCHY**" &amp; vblf
            Exit Do
        End If
        colExceptionPtrs.Add clrExceptionPtr, Empty

        clrExceptionType = GetManagedExceptionType(clrExceptionPtr)
        If clrExceptionType &lt;&gt; NOT_FOUND Then
            clrExceptionMsg = GetManagedExceptionMsg(clrExceptionPtr)
        End If
        tabCount = tabCount + 1
    Loop
    
    details = details &amp; Tabs(1) &amp; "Stack:    " &amp; vblf &amp; clrStack &amp; vblf

    GetClrExceptionDetails = GetClrExceptionDetails &amp; " DetailID = " &amp; GetExceptionDetailsID(details) &amp; vblf
End Function

Function GetVB6ExceptionDetails(vbErrorNum, vbErrorSrc, vbErrorDesc, exceptionRate)
    If Not INCLUDE_EXCEPTION_SUMMARY Then 
        GetVB6ExceptionDetails = GetVB6ExceptionDetails &amp; vblf
        Exit Function
    End If

    Dim details

    details = details &amp; vbTab &amp; "VB6 Err Number:  " &amp; vbErrorNum &amp; vblf
    details = details &amp; vbTab &amp; "Source:          " &amp; vbErrorSrc &amp; vblf
    details = details &amp; vbTab &amp; "Description:     " &amp; vbErrorDesc &amp; vblf
    details = details &amp; vbTab &amp; "Stack:" &amp; vblf &amp; GetCleanNativeStack(exceptionRate, "VB6 Error #" &amp; vbErrorNum) &amp; vblf
    GetVB6ExceptionDetails = GetVB6ExceptionDetails &amp; " DetailID = " &amp; GetExceptionDetailsID(details) &amp; vblf
End Function

Function GetNativeExceptionDetails(exceptionCode, exceptionRate)
    If Not INCLUDE_EXCEPTION_SUMMARY Then 
        GetNativeExceptionDetails = GetNativeExceptionDetails &amp; vblf
        Exit Function
    End If

    Dim details

    details = details &amp; vbTab &amp; "Exception #:  " &amp; exceptionCode &amp; vblf
    details = details &amp; vbTab &amp; "Stack:        " &amp; vblf &amp; GetCleanNativeStack(exceptionRate, exceptionCode) &amp; vblf
    GetNativeExceptionDetails = GetNativeExceptionDetails &amp; " DetailID = " &amp; GetExceptionDetailsID(details) &amp; vblf
End Function

' End Static Code

Sub Debugger_OnInitialBreakpoint()
	WriteToLog "Initializing control script"
	WriteToLog "Clearing any existing breakpoints"
	WriteToLog Debugger.Execute("bc *")

	WriteToLog "Current Breakpoint List(BL)"
	DebuggerWrite Debugger.Execute("bl")
End Sub

Sub Debugger_OnException(ByVal ObjException, ByVal CausingThread, ByVal FirstChance)
	Dim ExceptionCode, clrExceptionType, clrExceptionMsg
	ExceptionCode = UCase(Debugger.GetAs32BitHexString(ObjException.ExceptionCode))
	HandleException Exception, ExceptionCode, CausingThread, FirstChance, clrExceptionType, clrExceptionMsg

	Select Case ExceptionCode
		Case "0XC00000FD"
			If DbgState("Exception_C00000FD::_ACTION_COUNT") &lt; 1 Then
				CreateDump "First Chance Stack Overflow", false
				DbgState("Exception_C00000FD::_ACTION_COUNT") = DbgState("Exception_C00000FD::_ACTION_COUNT") + 1
				If DbgState("Exception_C00000FD::_ACTION_COUNT") &gt;= 1 Then
					WriteToLog "Action limit of 1 reached for Exception 0xC00000FD::."
				End If
			End If
		Case Else
			CreateDump "First chance exception " &amp; ExceptionCode, false
			
	End Select
End Sub

Sub Debugger_OnLoadModule(ByVal NewModule)
	WriteToLog NewModule.ImageName &amp; " loaded at " &amp; Debugger.GetAs32BitHexString(NewModule.Base)
	Select Case UCase(NewModule.ModuleName)
		Case "MSCORWKS", "MSCORSVR", "CLR", "CORECLR"
			ClrInit
			UpdateDeferredManagedBreakpoints
	End Select
End Sub

Sub Debugger_OnUnLoadModule(ByVal UnloadedModule)
	WriteToLog UnloadedModule.ImageName &amp; " Unloaded from " &amp; Debugger.GetAs32BitHexString(UnloadedModule.Base)
End Sub

Sub Debugger_OnCreateProcess(ByVal BaseModule, ByVal BaseThread)
	WriteToLog "Process created. BaseModule - " &amp; BaseModule.ImageName &amp; _
	  ". BaseThread - " &amp; GetThreadID(BaseThread)
End Sub

Sub Debugger_OnExitProcess(ByVal ExitCode)
	WriteToLog "Process exited. Exit code - " &amp; Debugger.GetAs32BitHexString(ExitCode)
	WriteLogFooter
End Sub

Sub Debugger_OnCreateThread(ByVal NewThread)
	WriteToLog "Thread created. New thread - " &amp; GetThreadID(NewThread)
End Sub

Sub Debugger_OnExitThread(ByVal ExitingThread, ByVal ExitCode)
	WriteToLog "Thread exited. Exiting thread - " &amp; GetThreadID(ExitingThread) &amp; _
	  ". Exit code - " &amp; Debugger.GetAs32BitHexString(ExitCode)
End Sub

Sub Debugger_OnBreakPoint(ByVal BreakPoint, ByVal CausingThread)
	WriteToLog "Breakpoint id " &amp; Breakpoint.ID &amp; " at " &amp; BreakPoint.OffsetExpression &amp; " caused by " &amp; GetThreadID(CausingThread)

	UpdateDeferredManagedBreakpoints

End Sub</value>
    <comment>{0}=process name, eg. Soex.C.exe, {1}=Uppercase of {0}</comment>
  </data>
</root>